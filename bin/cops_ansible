#!/usr/bin/env bash
#
# Convenient wrapper to scan & add to ansible search paths :
#   - inventories
#   - libraries
#   - roles
#   - plugins
#
# From where we call the ansible commands from
#   - $PWD
#   - $PWD/<one_leve_dir eg bin>/THIS_SCRIPT
#   - $PWD/ansible
#   - $PWD/.ansible
# Idem with directories from corpusops
#   - $SCRIPT_ROOT
#   - $SCRIPT_ROOT/ansible
#   - $SCRIPT_ROOT/.ansible
#
# This script will also activate any venv found inside $SCRIPT_ROOT/venv
#
# It makes also some sensible defaults:
#   - nosshhostkeychecking
#   - nocows
#   - better controlpath


# scripts vars
SCRIPT=$0
LOGGER_NAME=${LOGGER_NAME-$(basename $0)}
SCRIPT_NAME=$(basename "${SCRIPT}")
SCRIPT_DIR=$(cd "$(dirname $0)" && pwd)
# OW: from where script was called (must be defined from callee)
OW="${OW:-$(pwd)}"
# W is script_dir/..
W=${W:-$(cd "$SCRIPT_DIR/.." && pwd)}
# colors
RED="\\e[0;31m"
CYAN="\\e[0;36m"
YELLOW="\\e[0;33m"
NORMAL="\\e[0;0m"
NO_COLOR=${NO_COLORS-${NO_COLORS-${NOCOLOR-${NOCOLORS-}}}}
LOGGER_NAME=${LOGGER_NAME:-corpusops_build}
ERROR_MSG="There were errors"
do_trap_() { rc=$?;func=$1;sig=$2;${func};if [ "x${sig}" != "xEXIT" ];then kill -${sig} $$;fi;exit $rc; }
do_trap() { rc=${?};func=${1};shift;sigs=${@};for sig in ${sigs};do trap "do_trap_ ${func} ${sig}" "${sig}";done; }
parse_cli() { parse_cli_common "${@}"; }
parse_cli_common() {
    USAGE=
    for i in ${@-};do
        case ${i} in
            --no-color|--no-colors|--nocolor|--no-colors)
                NO_COLOR=1;;
            -h|--help)
                USAGE=1;;
            *) :;;
        esac
    done
    reset_colors
    if [[ -n ${USAGE} ]]; then
        usage
    fi
}
log_() {
    reset_colors;msg_color=${2:-${YELLOW}};
    logger_color=${1:-${RED}};
    logger_slug="${logger_color}[${LOGGER_NAME}]${NORMAL} ";
    shift;shift;
    if [[ -n ${NO_LOGGER_SLUG} ]];then logger_slug="";fi
    printf "${logger_slug}${msg_color}$(echo "${@}")${NORMAL}\n" >&2;
    printf "" >&2;  # flush
}
reset_colors() { if [[ -n ${NO_COLOR} ]];then BLUE="";YELLOW="";RED="";CYAN="";fi; }
log() { log_ "${RED}" "${CYAN}" "${@}"; }
get_chrono() { date "+%F_%H-%M-%S"; }
cronolog() { log_ "${RED}" "${CYAN}" "($(get_chrono)) ${@}"; }
debug() { if [[ -n "${DEBUG// }" ]];then log_ "${YELLOW}" "${YELLOW}" "${@}"; fi; }
warn() { log_ "${RED}" "${CYAN}" "${YELLOW}[WARN] ${@}${NORMAL}"; }
bs_log(){ log_ "${RED}" "${YELLOW}" "${@}"; }
bs_yellow_log(){ log_ "${YELLOW}" "${YELLOW}" "${@}"; }
may_die() {
    reset_colors
    thetest=${1:-1}
    rc=${2:-1}
    shift
    shift
    if [ "x${thetest}" != "x0" ]; then
        if [[ -z "${NO_HEADER-}" ]]; then
            NO_LOGGER_SLUG=y log_ "" "${CYAN}" "Problem detected:"
        fi
        NO_LOGGER_SLUG=y log_ "${RED}" "${RED}" "$@"
        exit $rc
    fi
}
die() { may_die 1 1 "${@}"; }
die_in_error_() {
    ret=${1}; shift; msg="${@:-"$ERROR_MSG"}";may_die "${ret}" "${ret}" "${msg}";
}
die_in_error() { die_in_error_ "${?}" "${@}"; }
has_command() {
    ret=1
    if which which >/dev/null 2>/dev/null;then
      if which "${@}" >/dev/null 2>/dev/null;then
        ret=0
      fi
    else
      if command -v "${@}" >/dev/null 2>/dev/null;then
        ret=0
      else
        if hash -r "${@}" >/dev/null 2>/dev/null;then
            ret=0
        fi
      fi
    fi
    return ${ret}
}
pipe_return() {
    local filter=$1;shift;local command=$@;
    (((($command; echo $? >&3) | $filter >&4) 3>&1) | (read xs; exit $xs)) 4>&1;
}
output_in_error() { ( do_trap output_in_error_post EXIT TERM QUIT INT;\
                      output_in_error_ "${@}" ; ); }
output_in_error_(){
    if [[ -n ${OUTPUT_IN_ERROR_DEBUG-} ]];then set -x;fi
    if [[ -n $TRAVIS ]] || [[ -n $GITLAB_CI ]];then
        DEFAULT_CI_BUILD=y
    fi
    CI_BUILD="${CI_BUILD-${DEFAULT_CI_BUILD-}}"
    if [[ -n $CI_BUILD ]];then
        DEFAULT_NO_OUTPUT=y
        DEFAULT_DO_OUTPUT_TIMER=y
    fi
    VERBOSE="${VERBOSE-}"
    TIMER_FREQUENCE="${TIMER_FREQUENCE:-120}"
    NO_OUTPUT="${NO_OUTPUT-${DEFAULT_NO_OUTPUT-1}}"
    DO_OUTPUT_TIMER="${DO_OUTPUT_TIMER-$DEFAULT_DO_OUTPUT_TIMER}"
    LOG=${LOG-}
    if [[ -n $NO_OUTPUT ]];then
        if [[ -z "${LOG}" ]];then
            LOG=$(mktemp)
            DEFAULT_CLEANUP_LOG=y
        else
            DEFAULT_CLEANUP_LOG=
        fi
    else
        DEFAULT_CLEANUP_LOG=
    fi
    CLEANUP_LOG=${CLEANUP_LOG:-${DEFAULT_CLEANUP_LOG}}
    if [[ -n $VERBOSE ]];then
        log "Running$([[ -n $LOG ]] && echo "($LOG)"; ): $@";
    fi
    TMPTIMER=
    if [[ -n ${DO_OUTPUT_TIMER} ]]; then
        TMPTIMER=$(mktemp)
        ( i=0;\
          while test -f $TMPTIMER;do\
           i=$((++i));\
           if [ `expr $i % $TIMER_FREQUENCE` -eq 0 ];then \
               log "BuildInProgress$([[ -n $LOG ]] && echo "($LOG)"; ): ${@}";\
             i=0;\
           fi;\
           sleep 1;\
          done;\
          if [[ -n $VERBOSE ]];then log "done: ${@}";fi; ) &
    fi
    if [[ -n $NO_OUTPUT ]];then
        "${@}" >>"$LOG" 2>&1;ret=$?
    else
        if [[ -n $LOG ]] && has_command tee;then
            pipe_return "tee -a $LOG" "${@}";ret=$?
        else
            "${@}";ret=$?
        fi
    fi
    if [[ -e "$TMPTIMER" ]]; then rm -f "${TMPTIMER}";fi
    if [[ -z ${OUTPUT_IN_ERROR_NO_WAIT-} ]];then wait;fi
    if [ -e "$LOG" ] &&  [[ "${ret}" != "0" ]] && [[ -n $NO_OUTPUT ]];then
        cat "$LOG" >&2
    fi
    if [[ -n ${OUTPUT_IN_ERROR_DEBUG-} ]];then set +x;fi
    return ${ret}
}
output_in_error_post() {
    if [[ -e "$TMPTIMER" ]]; then rm -f "${TMPTIMER}";fi
    if [[ -e "$LOG" ]] && [[ -n $CLEANUP_LOG ]];then rm -f "$LOG";fi
}
test_silent_log() { ( [[ -z ${NO_SILENT-} ]] && ( [[ -n ${SILENT_LOG-} ]] || [[ -n "${SILENT_DEBUG}" ]] ) ); }
test_silent() { ( [[ -z ${NO_SILENT-} ]] && ( [[ -n ${SILENT-} ]] || test_silent_log ) ); }
silent_run_() { (LOG=${SILENT_LOG:-${LOG}};NO_OUTPUT=;\
                 if test_silent;then NO_OUTPUT=y;fi;output_in_error "$@";) }
silent_run() { ( silent_run_ "${@}" ; ); }
run_silent() { SILENT=${SILENT-1} silent_run "${@}"; }
vvv() { debug "${@}";silent_run "${@}"; }
vv() { log "${@}";silent_run "${@}";}
silent_vv() { SILENT_LOG=${SILENT_LOG-} SILENT=${SILENT-1} vv "${@}"; }
version_lte() { [  "$1" = "$(printf "$1\n$2" | sort -V | head -n1)" ]; }
version_lt() { [ "$1" = "$2" ] && return 1 || version_lte $1 $2; }
version_gte() { [  "$2" = "$(printf "$1\n$2" | sort -V | head -n1)" ]; }
version_gt() { [ "$1" = "$2" ] && return 1 || version_gte $1 $2; }
is_archlinux_like() { echo $DISTRIB_ID | egrep -iq "archlinux"; }
is_debian_like() { echo $DISTRIB_ID | egrep -iq "debian|ubuntu|mint"; }
is_redhat_like() { echo $DISTRIB_ID | egrep -iq "fedora|centos|redhat|red-hat"; }
set_lang() { locale=${1:-C};export LANG=${locale};export LC_ALL=${locale}; }
detect_os() {
    # this function should be copiable in other scripts, dont use adjacent functions
    UNAME="${UNAME:-"$(uname | awk '{print tolower($1)}')"}"
    PATH="${PATH}:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games"
    SED="sed"
    if [ "x${UNAME}" != "xlinux" ] && hash -r gsed >/dev/null 2>&1; then
        SED=gsed
    fi
    DISTRIB_CODENAME=""
    DISTRIB_ID=""
    DISTRIB_RELEASE=""
    if hash -r lsb_release >/dev/null 2>&1; then
        DISTRIB_ID=$(lsb_release -si)
        DISTRIB_CODENAME=$(lsb_release -sc)
        DISTRIB_RELEASE=$(lsb_release -sr)
    elif [ -e /etc/lsb-release ];then
        debug "No lsb_release, sourcing manually /etc/lsb-release"
        DISTRIB_ID=$(. /etc/lsb-release;echo ${DISTRIB_ID})
        DISTRIB_CODENAME=$(. /etc/lsb-release;echo ${DISTRIB_CODENAME})
        DISTRIB_RELEASE=$(. /etc/lsb-release;echo ${DISTRIB_RELEASE})
    elif [ -e /etc/os-release ];then
        DISTRIB_ID=$(. /etc/os-release;echo $ID)
        DISTRIB_CODENAME=$(. /etc/os-release;echo $VERSION)
        DISTRIB_CODENAME=$(echo $DISTRIB_CODENAME |sed -e "s/.*(\([^)]\+\))/\1/")
        DISTRIB_RELEASE=$(. /etc/os-release;echo $VERSION_ID)
    elif [ -e /etc/redhat-release ];then
        RHRELEASE=$(cat /etc/redhat-release)
        DISTRIB_CODENAME=${RHRELEASE}
        DISTRIB_RELEASE=${RHRELEASE}
        DISTRIB_ID=${RHRELEASE}
        DISTRIB_CODENAME=$(echo $DISTRIB_CODENAME |sed -e "s/.*(\([^)]\+\))/\1/")
        DISTRIB_RELEASE=$(echo $DISTRIB_RELEASE |sed -e "s/release \([0-9]\)/\1/")
        DISTRIB_ID=$(echo $DISTRIB_ID | awk '{print tolower($1)}')
    else
        if ! ( echo ${@-} | grep -q no_fail );then
            echo "unexpected case, no lsb_release" >&2
            exit 1
        fi
    fi
    export DISTRIB_ID DISTRIB_CODENAME DISTRIB_RELEASE
}
get_command() {
    local p=
    local cmd="${@}"
    if which which >/dev/null 2>/dev/null;then
        p=$(which "${cmd}" 2>/dev/null)
    fi
    if [ "x${p}" = "x" ];then
        p=$(export IFS=:;
            echo "${PATH-}" | while read -ra pathea;do
                for pathe in "${pathea[@]}";do
                    pc="${pathe}/${cmd}";
                    if [ -x "${pc}" ]; then
                        p="${pc}"
                    fi
                done
                if [ "x${p}" != "x" ]; then echo "${p}";break;fi
            done )
    fi
    if [ "x${p}" != "x" ];then
        echo "${p}"
    fi
}


export A=${W}/ansible
export DA=${W}/.ansible
export OA=${OW}/ansible
export ODA=${OW}/.ansible
export SYS_A=${SYS_A:-/etc/ansible}
export VENV_PATH="${VENV_PATH-${W}/venv}"
PLUGINS_OR_MODULES_DIRS="\
ANSIBLE_LIBRARY:library
ANSIBLE_ACTION_PLUGINS:action_plugins
ANSIBLE_CACHE_PLUGINS:cache_plugins
ANSIBLE_CALLBACK_PLUGINS:callback_plugins
ANSIBLE_LOOKUP_PLUGINS:lookup_plugins
ANSIBLE_CONNECTION_PLUGINS:connection_plugins
ANSIBLE_INVENTORY_PLUGINS:inventory_plugins
ANSIBLE_FILTER_PLUGINS:filter_plugins
ANSIBLE_TEST_PLUGINS:test_plugins
ANSIBLE_STRATEGY_PLUGINS:strategy_plugins"

if [ -e "${VENV_PATH}/bin/activate" ]; then
    . "${VENV_PATH}/bin/activate"
else
    warn "virtualenv not found in ${VENV_PATH}, fallback to system ansible"
fi

while read p;do
    if [ -e "${p}" ];then
        for inventory in "${p}/inventories" "${p}/inventory";do
            if [ -e "${inventory}" ] && [[ -z ${ANSIBLE_HOSTS-} ]] ; then
                export ANSIBLE_HOSTS="${inventory}"
            fi
        done
        if [[ -z "${NO_ANSIBLE_CONTEXTUAL_PLUGINS_LOAD}" ]];then
            while read line;do
                var=$(echo "$line:"|cut -d: -f1)
                path=$(echo "$line:"|cut -d: -f2)
                testdir="${p}/${path}"
                if [ -e "${testdir}" ];then
                    eval 'val=$'"${var}"
                    if [[ -z ${val-} ]]; then
                        subpaths="${testdir}"
                        eval ${var}'="'${testdir}'"'
                    else
                        subpaths="${testdir}:${subpaths}"
                    fi
                    eval export ${var}'="'${subpaths}'"'
                fi
            done <<< "${PLUGINS_OR_MODULES_DIRS}"
        fi
        roles="${p}/roles"
        if [ -e "${roles}" ];then
            if [[ -z ${ANSIBLE_ROLES_PATH-} ]]; then
                export ANSIBLE_ROLES_PATH="${roles}"
            else
                export ANSIBLE_ROLES_PATH="${ANSIBLE_ROLES_PATH}:${roles}"
            fi
        fi
    fi
done < <(find \
            "${W}" "${OW}" \
            "${ODA}" "${OA}" \
            "${DA}" "${A}" \
            "${SYS_A}" \
            -mindepth 0 -maxdepth 0 -and \
            \( -type d -or -type l \) \
            2>/dev/null | awk '!seen[$0]++' )
export ANSIBLE_SSH_CONTROL_PATH=${ANSIBLE_SSH_CONTROL_PATH:-"~/.assh_%%h.%%p-%%r"}
export ANSIBLE_HOST_KEY_CHECKING${ANSIBLE_HOST_KEY_CHECKING:-"False"}
export ANSIBLE_NOCOWS=${ANSIBLE_NOCOWS-1}
DEFAULT_ANSIBLE_SQUASH_ACTIONS="apk,apt,dnf,homebrew,package,pacman,pkgng,yum,zypper"
export ANSIBLE_SQUASH_ACTIONS=${ANSIBLE_SQUASH_ACTIONS-$DEFAULT_ANSIBLE_SQUASH_ACTIONS}

if [[ -n ${ENV_DEBUG-} ]]; then
    env
    exit 1
fi
# if not included, but executed directly from a wrapper
if echo "${SCRIPT_NAME}" | egrep -vq '^cops_ansible$';then
    exec ${SCRIPT_NAME} "${@}"
fi
