#!/usr/bin/env bash

# W is script_dir/..
W=${W:-$(pwd)}
# OW: from where script was called (must be defined from callee)
OW="${OW:-${W}}"
RED="\\e[0;31m"
CYAN="\\e[0;36m"
YELLOW="\\e[0;33m"
NORMAL="\\e[0;0m"
NO_COLOR=${NO_COLORS-${NO_COLORS-${NOCOLOR-${NOCOLORS-}}}}
LOGGER_NAME=${LOGGER_NAME:-corpusops_build}
ERROR_MSG="There were errors"
ANSIBLE_FILTER_OUTPUT="(^("
ANSIBLE_FILTER_OUTPUT="${ANSIBLE_FILTER_OUTPUT}(included|skipping):|"
ANSIBLE_FILTER_OUTPUT="${ANSIBLE_FILTER_OUTPUT}(task|play)\s+(recap|\[(debug|all|include|setup)\])|"
ANSIBLE_FILTER_OUTPUT="${ANSIBLE_FILTER_OUTPUT}\s*$|"
ANSIBLE_FILTER_OUTPUT="${ANSIBLE_FILTER_OUTPUT}(ok|changed):\s+\[localhost\]( => {)?$|"
ANSIBLE_FILTER_OUTPUT="${ANSIBLE_FILTER_OUTPUT}\s*(\"msg|([{}]$))"
ANSIBLE_FILTER_OUTPUT="${ANSIBLE_FILTER_OUTPUT}))"

get_random_slug() {
    len=${1:-32}
    strings=${2:-'a-zA-Z0-9'}
    echo "$(cat /dev/urandom \
        | tr -dc "$strings" \
        | fold -w ${len} \
        | head -n 1)"
}

reset_colors() {
    if [[ -n ${NO_COLOR} ]]; then
        BLUE=""
        YELLOW=""
        RED=""
        CYAN=""
    fi
}

log_() {
    reset_colors
    logger_color=${1:-${RED}}
    msg_color=${2:-${YELLOW}}
    shift;shift;
    logger_slug="${logger_color}[${LOGGER_NAME}]${NORMAL} "
    if [[ -n ${NO_LOGGER_SLUG} ]];then
        logger_slug=""
    fi
    printf "${logger_slug}${msg_color}$(echo "${@}")${NORMAL}\n" >&2;
    printf "" >&2;  # flush
}

log(){
    log_ "${RED}" "${CYAN}" "${@}"
}

may_die() {
    reset_colors
    thetest=${1:-1}
    rc=${2:-1}
    shift
    shift
    if [ "x${thetest}" != "x0" ]; then
        if [[ -z "${NO_HEADER-}" ]]; then
            NO_LOGGER_SLUG=y log_ "" "${CYAN}" "Problem detected:"
        fi
        NO_LOGGER_SLUG=y log_ "${RED}" "${RED}" "$@"
        exit $rc
    fi
}

die() {
    may_die 1 1 "${@}"
}

die_in_error_() {
    ret=${1}
    shift
    msg="${@:-"$ERROR_MSG"}"
    may_die "${ret}" "${ret}" "${msg}"
}

die_in_error() {
    die_in_error_ "${?}" "${@}"
}

debug() {
    if [[ -n "${DEBUG// }" ]];then
        log_ "${YELLOW}" "${YELLOW}" "${@}"
    fi
}

vvv() {
    debug "${@}"
    "${@}"
}

vv() {
    log "${@}"
    "${@}"
}

usage() {
    die 128 "No usage found"
}

cleanup_docker_tag() {
    echo "${@}" | sed -re "s/\.|[-_]//g" \
        | awk '{print tolower($0)}'
}

parse_cli_common() {
    USAGE=
    for i in ${@-};do
        case ${i} in
            --no-color|--no-colors|--nocolor|--no-colors)
                NO_COLOR=1;;
            -h|--help)
                USAGE=1;;
            *) :;;
        esac
    done
    reset_colors
    if [[ -n ${USAGE} ]]; then
        usage
    fi
}

parse_cli() {
    parse_cli_common "${@}"
}

get_chrono() {
    date "+%F_%H-%M-%S"
}

get_full_chrono() {
    date "+%F_%H-%M-%S-%N"
}

get_images() {
    docker images --no-trunc -q "${@}" 2>/dev/null | sort -u
}

get_image() {
    get_images "${@}" | head -n 1
}

detect_os() {
    UNAME="${UNAME:-"$(uname | awk '{print tolower($1)}')"}"
    PATH="${PATH}:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games"
    SED=$(which sed)
    if [ "x${UNAME}" != "xlinux" ]; then
        SED=$(which gsed)
    fi
    DISTRIB_CODENAME=""
    DISTRIB_ID=""
    if hash -r lsb_release >/dev/null 2>&1; then
        DISTRIB_ID=$(lsb_release -si)
        DISTRIB_CODENAME=$(lsb_release -sc)
        DISTRIB_RELEASE=$(lsb_release -sr)
    elif [ -e /etc/lsb-release ];then
        log "No lsb_release, sourcing manually /etc/lsb-release"
        . /etc/lsb-release
    else
        if ! ( echo ${@-} | grep -q no_fail );then
            die "unespected case, no lsb_release"
        fi
    fi
}

filtered_ansible_playbook_custom() {
    filter=${1:-${ANSIBLE_FILTER_OUTPUT}}
    shift
    (((( \
        vv bin/ansible-playbook  "${@}" ; echo $? >&3) \
        | egrep -iv "${filter}" >&4) 3>&1) \
        | (read xs; exit $xs)) 4>&1
    return $?
}

filtered_ansible_playbook() {
    filtered_ansible_playbook_ "" "${@}"

}

output_in_error() {
    slug_to_call="${@}"
    NO_OUTPUT="${NO_OUTPUT-}"
    DO_OUTPUT_TIMER="${DO_OUTPUT_TIMER-1}"
    if [[ -z $NO_OUTPUT ]]; then
        DO_OUTPUT_TIMER=""
    else
        LOG=$(mktemp)
    fi
    if [[ -n ${DO_OUTPUT_TIMER} ]]; then
        TMP=$(mktemp)
        ( i=0;\
          while test -f $TMP;do\
           i=$((++i));\
           if [[ $i == 120 ]];then \
             log "BuildInProgress($LOG): ${slug_to_call}";\
             i=0;\
           fi;\
           sleep 1;\
          done;\
          log "done: ${slug_to_call}"; ) &
    fi
    if [[ -n $NO_OUTPUT ]]; then
        log "Log: $LOG"
        ${slug_to_call} >"$LOG" 2>&1
        ret=${?}
        if [ -e "$LOG" ];then
            if [ "x${ret}" != "x0" ];then
                vv cat "$LOG" >&2
            fi
            rm -f "$LOG"
        fi
    else
        ${slug_to_call}
        ret=${?}
    fi
    if [[ -n $DO_OUTPUT_TIMER ]]; then
        rm -f "${TMP}"
    fi
    return ${ret}
}

get_git_changeset() {
   ( cd "${1:-$(pwd)}" &&\
     git log HEAD|head -n1|awk '{print $2}')
}

get_git_branch() {
   ( cd "${1:-$(pwd)}" &&\
     git rev-parse --abbrev-ref HEAD | grep -v HEAD || \
     git describe --exact-match HEAD 2> /dev/null || \
     git rev-parse HEAD)
}

detect_os no_fail
# vim:set et sts=4 ts=4 tw=80:
