#!/usr/bin/env bash
OW=$(pwd)
cd $(dirname $0)/..
export LOGGER_NAME=$(basename $0)

# W is script_dir/..
W=${W:-$(pwd)}
# OW: from where script was called (must be defined from callee)
OW="${OW:-${W}}"
RED="\\e[0;31m"
CYAN="\\e[0;36m"
YELLOW="\\e[0;33m"
NORMAL="\\e[0;0m"
NO_COLOR=${NO_COLORS-${NO_COLORS-${NOCOLOR-${NOCOLORS-}}}}
LOGGER_NAME=${LOGGER_NAME:-corpusops_build}
ERROR_MSG="There were errors"
do_trap_() { rc=$?;func=$1;sig=$2;${func};if [ "x${sig}" != "xEXIT" ];then kill -${sig} $$;fi;exit $rc; }
do_trap() { rc=${?};func=${1};shift;sigs=${@};for sig in ${sigs};do trap "do_trap_ ${func} ${sig}" "${sig}";done; }
log_() {
    reset_colors;msg_color=${2:-${YELLOW}};
    logger_color=${1:-${RED}};
    logger_slug="${logger_color}[${LOGGER_NAME}]${NORMAL} ";
    shift;shift;
    if [[ -n ${NO_LOGGER_SLUG} ]];then logger_slug="";fi
    printf "${logger_slug}${msg_color}$(echo "${@}")${NORMAL}\n" >&2;
    printf "" >&2;  # flush
}
reset_colors() { if [[ -n ${NO_COLOR} ]];then BLUE="";YELLOW="";RED="";CYAN="";fi; }
log() { log_ "${RED}" "${CYAN}" "${@}"; }
get_chrono() { date "+%F_%H-%M-%S"; }
cronolog() { log_ "${RED}" "${CYAN}" "($(get_chrono)) ${@}"; }
debug() { if [[ -n "${DEBUG// }" ]];then log_ "${YELLOW}" "${YELLOW}" "${@}"; fi; }
warn() { log_ "${RED}" "${CYAN}" "${YELLOW}[WARN] ${@}${NORMAL}"; }
bs_log(){ log_ "${RED}" "${YELLOW}" "${@}"; }
bs_yellow_log(){ log_ "${YELLOW}" "${YELLOW}" "${@}"; }
may_die() {
    reset_colors
    thetest=${1:-1}
    rc=${2:-1}
    shift
    shift
    if [ "x${thetest}" != "x0" ]; then
        if [[ -z "${NO_HEADER-}" ]]; then
            NO_LOGGER_SLUG=y log_ "" "${CYAN}" "Problem detected:"
        fi
        NO_LOGGER_SLUG=y log_ "${RED}" "${RED}" "$@"
        exit $rc
    fi
}
die() { may_die 1 1 "${@}"; }
die_in_error_() {
    ret=${1}; shift; msg="${@:-"$ERROR_MSG"}";may_die "${ret}" "${ret}" "${msg}";
}
die_in_error() { die_in_error_ "${?}" "${@}"; }
test_silent_log() { ( [[ -z ${NO_SILENT-} ]] && ( [[ -n ${SILENT_LOG-} ]] || [[ -n "${SILENT_DEBUG}" ]] ) ); }
test_silent() { ( [[ -z ${NO_SILENT-} ]] && ( [[ -n ${SILENT-} ]] || test_silent_log ) ); }
silent_run_post() { if [ -e "${tmpf}" ];then rm -f "${tmpf}";fi; }
silent_run_() {
    tmpf=$(mktemp)
    local ret=
    if ! test_silent;then
        "${@}"
        ret=${?}
    else
        do_trap silent_run_post EXIT TERM QUIT INT
        if test_silent_log;then
            log "Logging command output to ${tmpf}"
        fi
        "${@}" >"${tmpf}" 2>&1
        ret=${?}
        if [ "x${ret}" != "x0" ] && [ -e "${tmpf}" ]; then
            cat "${tmpf}"
        fi
    fi
    return ${ret}
}
silent_run() { ( silent_run_ "${@}" ; ); }
run_silent() { SILENT=${SILENT-1} silent_run "${@}"; }
vvv() { debug "${@}";silent_run "${@}"; }
vv() { log "${@}";silent_run "${@}";}
silent_vv() { SILENT_LOG=${SILENT_LOG-} SILENT=${SILENT-1} vv "${@}"; }
has_command() {
    ret=1
    if which which >/dev/null 2>/dev/null;then
      if which "${@}" >/dev/null 2>/dev/null;then
        ret=0
      fi
    else
      if command -v "${@}" >/dev/null 2>/dev/null;then
        ret=0
      else
        if hash -r "${@}" >/dev/null 2>/dev/null;then
            ret=0
        fi
      fi
    fi
    return ${ret}
}
get_command() {
    local p=
    local cmd="${@}"
    if which which >/dev/null 2>/dev/null;then
        p=$(which "${cmd}" 2>/dev/null)
    fi
    if [ "x${p}" = "x" ];then
        p=$(export IFS=:;
            echo "${PATH-}" | while read -ra pathea;do
                for pathe in "${pathea[@]}";do
                    pc="${pathe}/${cmd}";
                    if [ -x "${pc}" ]; then
                        p="${pc}"
                    fi
                done
                if [ "x${p}" != "x" ]; then echo "${p}";break;fi
            done )
    fi
    if [ "x${p}" != "x" ];then
        echo "${p}"
    fi
}
get_container_id() { local n=${1};local cid=$(docker ps -q -a --filter 'name='$n); echo "${cid}"; }
sane_container_name() { local n=${1};n=${n//:/};n=${n//_/};n=${n//-/};n=${n//\//};n=${n//\./};echo $n; }
get_images() { docker images --no-trunc -q "${@}" 2>/dev/null|awk '!seen[$0]++'; }
get_image() { get_images "${@}" | head -n 1; }
save_container() {
    local n="${1}"
    local d="${2:-${n}}"
    local running=$(docker ps -q    --filter 'name='$n)
    if [[ -n "${running}" ]];then
        vv docker kill "${running}"
    fi
    local cid=$(get_container_id $n)
    if [[ -n "${cid}" ]];then
        vv docker commit "$cid" "$d"
        vv docker rm "$cid"
    else
        img=${initial_img}
    fi
}

parse_cli_common() {
    USAGE=
    for i in ${@-};do
        case ${i} in
            --no-color|--no-colors|--nocolor|--no-colors)
                NO_COLOR=1;;
            -h|--help)
                USAGE=1;;
            *) :;;
        esac
    done
    reset_colors
    if [[ -n ${USAGE} ]]; then
        usage
    fi
}

parse_cli


reset_colors

usage() {
    NO_HEADER=y die '
Wrapper to test an image:
    - the container will be commited upon restarts
    - Current directory, and docker ones are mounted inside the container
    - It can cleanup produced tests with CLEANUP=1

You can even systemd based corpusops images like this:
 img="'"${img}"'" '"$0"' '"$default_ep"'

Or launch a shell
 - without args: img="'"${img}"'" '"$0"'
 - with args for docker or img: docker_args="-ti" img="'"${img}"'" '"$0"' bash

 [name=] \
 [docker_args=] \
 [img=corpusops/ubuntu:16.04] \
 [rootfs_mp=] \
 [rootfs_start_dir=] \
 [rootfs_mount_mode=] \
 [cwd_mp=] \
 [cwd_mount_mode=] \
 [INITIAL_CLEANUP=] [FINAL_CLEANUP=] [CLEANUP=]\
 [DEBUG=y] \
 [NOINPUT=] \
 [CLEANUP=] \
    '"$0"' [ ... image args ... ]
 '
}

sane_container_name() {
    local n=$1
    n=${n//:/}
    n=${n//_/}
    n=${n//-/}
    n=${n//\//}
    n=${n//\./}
    echo $n
}

save_container() {
    local n="${1}"
    local d="${2:-${n}}"
    # name is prepended by slash as for now
    local running=$(docker ps -q    --filter 'name=/?'$n'$')
    local cid=$(docker     ps -q -a --filter 'name=/?'$n'$')
    if [[ -n "${running}" ]];then
        vv docker kill "$running"
    fi
    local cid=$(docker     ps -q -a --filter 'name=/?'$n'$')
    if [[ -n "${cid}" ]];then
        vv docker commit "$cid" "$d"
        vv docker rm "$cid"
    else
        img=${initial_img}
    fi
}

cleanup() {
    local n=$1
    local CLEANUP_VARS="${CLEANUP_VARS:-"CLEANUP"}"
    local cleanuptest=
    for val in $CLEANUP_VARS;do
        eval "vval=$(echo \${${val}})"
        if [[ -n "${vval}" ]];then
            debug "Using $val as CLEANUP var"
            cleanuptest=${vval}
            break
        fi
    done
    if [[ -n ${cleanuptest} ]]; then
        docker rm -f $n 2>/dev/null
        docker rmi -f $n 2>/dev/null
    else
        log "Skip cleanup, to cleanup livetest images/docker: export one of "
        log "  $CLEANUP_VARS"
    fi
}

trap_cleanup() {
    ( CLEANUP_VARS="FINAL_CLEANUP CLEANUP" cleanup $n )
}

parse_cli() {
    parse_cli_common "${@}"
    if [[ -z ${docker_binary} ]];then
        die "no docker, install it first"
    fi
}

main() {
    ( CLEANUP_VARS="INITIAL_CLEANUP CLEANUP" cleanup $n )
    imgid=$(get_image "${n}")
    if [[ -n ${imgid} ]]; then
        log "Using preexisting $n <${imgid}>"
        img="${n}"
    fi
    myinput=
    while true; do
        vv "${docker_binary}" run \
            -e "CORPUSOPS_W=${W}"\
            -e CORPUSOPS_IN_DEV=1\
            --name="$n" \
            -v "/sys/fs/cgroup:/sys/fs/cgroup:ro" \
            $( while read v; do echo " -v ${v}:${v}:ro";done < \
                <( ldd "${docker_binary}" \
                   | egrep -v "libc.so|libpthread.so|libdl.so" \
                   | awk '{print $3}' | egrep '^/'; )
            )\
            $( if [[ "${OW}" == "${W}" ]];then
                while read v; do \
                    echo " -v ${v}:${v}:ro"; \
                    echo " -v ${v}:$COPS_ROOT/$(basename ${v}):ro"; \
                done < \
                    <( find "${W}" -maxdepth 1 -mindepth 1 \
                    | egrep -v "${W}/src|venv|requirements|roles|playbooks|/.corpusops"; )
                while read v; do \
                    echo " -v ${v}:${v}:rw"; \
                    echo " -v ${v}:$COPS_ROOT/$(basename ${v}):ro"; \
                done < \
                    <( find "${W}" -maxdepth 1 -mindepth 1 \
                    | egrep "${W}/(src|requirements|roles|playbooks)"; )
            fi
            )\
            -v "${docker_binary}:${docker_binary}" \
            -v "/var/lib/docker:/var/lib/docker" \
            -v "/var/run/docker:/var/run/docker" \
            -v "/var/run/docker.sock:/var/run/docker.sock" \
            -v "${rootfs_start_dir}:${rootfs_mp}${rootfs_mount_mode}" \
            -v "${OW}:${cwd_mp}${cwd_mount_mode}" \
            ${docker_args} \
            "${img}" \
            $( [[ -n "${img_args}" ]] && echo "${img_args}"; )
        SILENT=1 vv save_container $n
        imgid=$(get_image "${n}")
        if [[ -n ${imgid} ]]; then
            img=${imgid}
        fi
        if [[ -z NOINPUT ]]; then
            log "press enter to restart..."
            read myinput
            log "Restarting"
        else
            log "Restarting in 2 sec"
            sleep 2
        fi
    done
}

docker_binary=${docker_binary:-$(get_command docker)}
docker_args=${docker_args-}
default_ep=/entry_point
default_img="corpusops/ubuntu:16.04"
img="${img:-${default_img}}"
initial_img=${img}
n=${name:-$(sane_container_name ${img}_livetest)}
rootfs_mount_mode="${rootfs_mount_mode:-:ro}"
rootfs_start_dir="${rootfs_start_dir:-/}"
rootfs_mp="${rootfs_mp:-/HOST_ROOTFS}"
cwd_mp="${cwd_mp:-/HOST_CWD}"
cwd_mount_mode="${rootfs_mount_mode:-}"
default_ep=$W/hacking/container_rootfs/$default_ep
img_args="${@}"

parse_cli "${@}"
do_trap trap_cleanup EXIT

main
# vim:set et sts=4 ts=4 tw=80:
