#!/usr/bin/env bash
export LOGGER_NAME=$(basename $0)

# W is script_dir/..
W=${W:-$(pwd)}
# OW: from where script was called (must be defined from callee)
OW="${OW:-${W}}"
RED="\\e[0;31m"
CYAN="\\e[0;36m"
YELLOW="\\e[0;33m"
NORMAL="\\e[0;0m"
NO_COLOR=${NO_COLORS-${NO_COLORS-${NOCOLOR-${NOCOLORS-}}}}
LOGGER_NAME=${LOGGER_NAME:-corpusops_build}
ERROR_MSG="There were errors"
log_() {
    reset_colors;msg_color=${2:-${YELLOW}};
    logger_color=${1:-${RED}};
    logger_slug="${logger_color}[${LOGGER_NAME}]${NORMAL} ";
    shift;shift;
    if [[ -n ${NO_LOGGER_SLUG} ]];then logger_slug="";fi
    printf "${logger_slug}${msg_color}$(echo "${@}")${NORMAL}\n" >&2;
    printf "" >&2;  # flush
}
reset_colors() { if [[ -n ${NO_COLOR} ]];then BLUE="";YELLOW="";RED="";CYAN="";fi; }
log() { log_ "${RED}" "${CYAN}" "${@}"; }
cronolog() { log_ "${RED}" "${CYAN}" "($(get_chrono)) ${@}"; }
debug() { if [[ -n "${DEBUG// }" ]];then log_ "${YELLOW}" "${YELLOW}" "${@}"; fi; }
warn() { log_ "${RED}" "${CYAN}" "${YELLOW}[WARN] ${@}${NORMAL}"; }
bs_log(){ log_ "${RED}" "${YELLOW}" "${@}"; }
bs_yellow_log(){ log_ "${YELLOW}" "${YELLOW}" "${@}"; }
may_die() {
    reset_colors
    thetest=${1:-1}
    rc=${2:-1}
    shift
    shift
    if [ "x${thetest}" != "x0" ]; then
        if [[ -z "${NO_HEADER-}" ]]; then
            NO_LOGGER_SLUG=y log_ "" "${CYAN}" "Problem detected:"
        fi
        NO_LOGGER_SLUG=y log_ "${RED}" "${RED}" "$@"
        exit $rc
    fi
}
die() { may_die 1 1 "${@}"; }
die_in_error_() {
    ret=${1}; shift; msg="${@:-"$ERROR_MSG"}";may_die "${ret}" "${ret}" "${msg}";
}
die_in_error() { die_in_error_ "${?}" "${@}"; }
get_chrono() { date "+%F_%H-%M-%S"; }
get_full_chrono() { date "+%F_%H-%M-%S-%N"; }
get_git_changeset() { ( cd "${1:-$(pwd)}" && git log HEAD|head -n1|awk '{print $2}'); }
get_git_branch() {
   ( cd "${1:-$(pwd)}" &&\
     git rev-parse --abbrev-ref HEAD | grep -v HEAD || \
     git describe --exact-match HEAD 2> /dev/null || \
     git rev-parse HEAD)
}
get_git_branchs() { ( cd "${1:-$(pwd)}" && git branch|sed -e "s/^\*\? \+//g"); }
test_silent_log() { ( [[ -z ${NO_SILENT-} ]] && ( [[ -n ${SILENT_LOG-} ]] || [[ -n "${SILENT_DEBUG}" ]] ) ); }
test_silent() { ( [[ -z ${NO_SILENT-} ]] && ( [[ -n ${SILENT-} ]] || test_silent_log ) ); }
silent_run_post() { if [ -e "${tmpf}" ];then rm -f "${tmpf}";fi; }
silent_run_() {
    tmpf=$(mktemp)
    local ret=
    if ! test_silent;then
        "${@}"
        ret=${?}
    else
        do_trap silent_run_post EXIT TERM QUIT INT
        if test_silent_log;then
            log "Logging command output to ${tmpf}"
        fi
        "${@}" >"${tmpf}" 2>&1
        ret=${?}
        if [ "x${ret}" != "x0" ] && [ -e "${tmpf}" ]; then
            cat "${tmpf}"
        fi
    fi
    return ${ret}
}
silent_run() { ( silent_run_ "${@}" ; ); }
run_silent() { SILENT=${SILENT-1} silent_run "${@}"; }
vvv() { debug "${@}";silent_run "${@}"; }
vv() { log "${@}";silent_run "${@}";}
silent_vv() { SILENT_LOG=${SILENT_LOG-} SILENT=${SILENT-1} vv "${@}"; }
output_in_error() {
    slug_to_call="${@}"
    NO_OUTPUT="${NO_OUTPUT-1}"
    DO_OUTPUT_TIMER="${DO_OUTPUT_TIMER-1}"
    if [[ -n ${DO_OUTPUT_TIMER} ]] || [[ -n $NO_OUTPUT ]];then
        LOG=$(mktemp)
    fi
    if [[ -n ${DO_OUTPUT_TIMER} ]]; then
        TMP=$(mktemp)
        ( i=0;\
          while test -f $TMP;do\
           i=$((++i));\
           if [ `expr $i % 120` -eq 0 ];then \
             log "BuildInProgress($LOG): ${slug_to_call}";\
             i=0;\
           fi;\
           sleep 1;\
          done;\
          log "done: ${slug_to_call}"; ) &
    fi
    if [[ -n $NO_OUTPUT ]]; then
        log "Log: $LOG for ${YELLOW}$slug_to_call"
        ${slug_to_call} >"$LOG" 2>&1
        ret=${?}
        if [ -e "$LOG" ];then
            if [ "x${ret}" != "x0" ];then
                vv cat "$LOG" >&2
            fi
            rm -f "$LOG"
        fi
    else
        ${slug_to_call}
        ret=${?}
    fi
    if [[ -n $DO_OUTPUT_TIMER ]]; then rm -f "${TMP}";fi
    if [[ -z ${OUTPUT_IN_ERROR_NO_WAIT-} ]];then wait;fi
    return ${ret}
}
get_images() { docker images --no-trunc -q "${@}" 2>/dev/null|awk '!seen[$0]++'; }
get_image() { get_images "${@}" | head -n 1; }
do_trap_() { rc=$?;func=$1;sig=$2;${func};if [ "x${sig}" != "xEXIT" ];then kill -${sig} $$;fi;exit $rc; }
do_trap() { rc=${?};func=${1};shift;sigs=${@};for sig in ${sigs};do trap "do_trap_ ${func} ${sig}" "${sig}";done; }

usage() {
    NO_HEADER=y die '
Release images to docker

 [OUTPUT_IN_ERROR=] \
 [FORCE_RELEASE=] \
 [DOCKER_RELEASER=xxx] \
 [DOCKER_PASSWORD=xxx] \
 [RELEASABLE_BRANCHES=xxx] \
 [DOCKER_USER=xxx] \
 [NOCOLOR=y] \
 [DEBUG=y] \
    '"$0"' WORKING_DIR <image> <image1>
 '
}

parse_cli() {
    [[ -z $DOCKER_RELEASER ]] && die "no DOCKER_RELEASER"
    [[ -z $DOCKER_PASSWORD ]] && die "no DOCKER_PASSWORD"

    if [[ -n ${1-} ]] && [ -d "${1}" ]; then
        RELEASED_DIR=${1}
        shift
    else
        RELEASED_DIR=${W}
    fi
    R_IMAGES="${@:-"${IMAGES}"}"
    R_IMAGES="$(echo "$R_IMAGES"|xargs -n1|awk '!seen[$0]++')"
    RELEASABLE=""
    for img in ${R_IMAGES};do
        fimg=${img}
        if echo ${fimg} | grep -vq /;then
            if [[ -z $DOCKER_USER ]];then
                die "no DOCKER_USER for $fimg"
            else
                fimg=${DOCKER_USER}/${img}
            fi
        fi
        tagid=$(get_image "${fimg}")
        if [ "x${tagid}" != "x" ]; then
            RELEASABLE="${RELEASABLE} ${fimg}"
        fi
    done
    RELEASABLE="$(echo "${RELEASABLE}" | xargs -n1)"
    RELEASABLE_BRANCHES="${RELEASABLE_BRANCHES:-"^master$"}"
    if [[ -z "${RELEASABLE}" ]]; then
        die "no releasable images produced yet from: ${YELLOW}$IMAGES"
    fi
}

release_test() {
    if [[ -n ${TRAVIS} ]]; then
        if [[ "${TRAVIS_PULL_REQUEST}" != "false" ]];then
            debug "Is a travis pull request, no release"
            return 1
        elif echo "${TRAVIS_BRANCH}"\
            | egrep -iq ${RELEASABLE_BRANCHES}; then
            return 0
        fi
    else
        if [[ -n ${FORCE_RELEASE} ]]; then
            return 0
        elif get_git_branch ${RELEASED_DIR}\
            | egrep -iq ${RELEASABLE_BRANCHES}; then
            return 0
        fi
    fi
    return 1
}

parse_cli "$@"
ret=0
if release_test; then
    log "Releasing ${RELEASABLE}"
    for img in ${RELEASABLE};do
        docker_registry=
        # registry
        image_pattern="\(\([^:]\+:[^/]\+\)\/\)\?"
        # repo
        image_pattern="${image_pattern}\(\(\([^\/:]\+\)\/\?\)"
        # image
        image_pattern="${image_pattern}\(\(\([^\/:]\+\)\/\?\)"
        # tag
        image_pattern="${image_pattern}:\?\(.*\)\)\)$"
        img_without_registry=$(echo "$img"|sed -e "s/$image_pattern/\3/g")
        docker_registry=$(echo "$img"|sed -e "s/$image_pattern/\2/g")
        vecho="";if [[ -n $FORCE_NO_RELEASE ]];then vecho="echo";fi
        if [[ -n $docker_registry ]];then
            log "docker login -> ${docker_registry}"
        else
            log "docker login"
        fi
        echo "$DOCKER_PASSWORD" | $vecho docker login --password-stdin \
            -u="$DOCKER_RELEASER" \
            $([[ -n ${docker_registry} ]] && echo "${docker_registry}")
        die_in_error "Login for $DOCKER_RELEASER failed on $docker_registry"
        ( if [[ -n "${docker_registry}" ]];then \
            output_in_error $vecho vv \
            push "${docker_registry}"/"${img_without_registry}";\
        else \
            output_in_error $vecho \
            vv push "${img_without_registry}";\
        fi
        )
        if [[ ${?} != 0 ]];then
            log "Failed to release: ${img}"
            ret=1
        else
            log "Released: ${img}"
        fi
    done
    log "release done"
else
    log "Release test failed, release skipped"
fi
die_in_error_ ${ret} "Release failed ($ret)"
# vim:set et sts=4 ts=4 tw=80:
