#!/usr/bin/env bash
OW=$(pwd)
cd "$(dirname ${0})/.."
export LOGGER_NAME=$(basename $0)

sc=hacking/build_env
[[ ! -e $sc ]] && echo "missing $sc" >&2
. "$sc" || exit 1

usage() {
    NO_HEADER=y die '
Wrapper to docker build, but will also try to squash any created layer up

 [NOCOLOR=y] \
 [NO_BUILD=y] \
 [FORCE_REPULL=y] \
 [FORCE_REBUILD=y] \
 [NO_SQUASH=y] \
 [NO_SQUASH_CLEANUP=y] \
 [NO_CANDIDATE_CLEANUP=y] \
 [NO_OLD_IMAGE_CLEANUP=y] \
 [DEBUG=y] \
    '"$0"' <tag> [<dockerfile>] [<path_to_working_dir>]
 '
}

parse_cli() {
    parse_cli_common "${@}"
    tag=$1
    dockerfile=${2-}
    wd=${3:-$OW}
    if [[ -z ${3-} ]];then
        # test if 2nd arg is a directory or a file (Dockerfile, in this case)
        if [[ -d ${2-} ]];then
            dockerfile=""
            wd=${2}
        fi
    fi
    local dockerfiles
    declare -a dockerfiles
    if [[ -n "${dockerfile}" ]];then
        dockerfiles=("$dockerfile" "$wd/$dockerfile")
    else
        dockerfiles=("Dockerfile.${tag}"
                     "$wd/Dockerfile.${tag}"
                     "Dockerfile"
                     "$wd/Dockerfile")
    fi
    for dfile in ${dockerfiles[@]};do
        if [ -e "${dfile}" ];then
            dockerfile="${dfile}"
            break
        fi
    done
    if [[ -z "${dockerfile}" ]];then
        die 4 "No dockerfile providen"
    fi
    if [ ! -e "${dockerfile}" ];then
        die 4 "Dockerfile $dockerfile does not exists"
    fi
    if [[ -z ${tag} ]];then
        die 5 "No tag providen"
    fi
    debug "Dockerfile: $dockerfile"
    debug "Tag: $tag"
    debug "WD: $wd"
}

parse_cli "$@"

#TMPS="$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 32 | head -n 1)"
candidate=${tag}_cops_candidate
taggued=${candidate}
candidate_squashed=${candidate}_s

ret=1

# If wanted, try to install image squasher if not already done
if [[ -n "${SQUASHER_URL}" ]] && [ ! -e "$SQUASHER" ];then
    echo "Getting $SQUASHER_URL -> $SQUASHER" &&\
    if echo $SQUASHER_URL | egrep -qi amd64;then
        curl -L -s "$SQUASHER_URL" \
            | tar xzvf - -C hacking \
            && chmod +x hacking/docker-squash \
            && mv -vf hacking/docker-squash "${SQUASHER}"
        may_die $? $? "$SQUASHER_URL failed to download"
    else
        if [ -e venv/bin/activate ]; then
            . venv/bin/activate
        fi
        pip install --upgrade -e "${SQUASHER_URL}"
    fi
fi

init_candidate_vars() {
    old_tag_id=$(get_image "${tag}")
    old_candidate_id=$(get_image "${candidate}")
    old_squashed_id=$(get_image "${candidate_squashed}")
    tag_id=${old_tag_id}
    candidate_id=${old_candidate_id}
    squashed_id=${old_squashed_id}
}


init_candidate_vars
dockerfile=${dockerfile:-${wd}/Dockerfile}
ancestor=
ancestor_id=

# If we are free from any candidates, build a new image
if [[ -n ${candidate_id} ]]; then
    if [[ -n ${FORCE_REBUILD} ]]; then
        SILENT_LOG=1 vv docker rmi -f "${candidate_id}"
        die_in_error "${candidate_id} cleanup failed"
        init_candidate_vars
    fi
fi

if [[ -z ${candidate_id} ]];then
    debug "No candidates found prior to build"
fi

ancestor=$(get_ancestor_from_dockerfile "${dockerfile}")

if [[ -n "${ancestor}" ]]; then
    ancestor_id=$(get_docker_ids "${ancestor}")
    ret=0
    if [[ -n "${FORCE_REPULL-}" ]] || [[ "${ancestor_id}" == "" ]]; then
        SILENT_LOG=1 vv docker pull "${ancestor}"
        ret=${?}
        ancestor_id=$(get_docker_ids "${ancestor}")
    fi
    if [[ ${ret} != 0 ]]; then
        if [[ "${ancestor_id}" != "" ]]; then
            warn "docker pull ${ancestor} failed"
            warn "but tag exists locally, using it"
        fi
    fi
    if [[ "${ancestor_id}" == "" ]]; then
        die "docker image: ${ancestor} not found"
    fi
    log "Ancestor ${CYAN}${ancestor} (id: ${ancestor_id})"
fi

if [[ -z ${NO_BUILD} ]]; then
    log "Building ${candidate}"
    SILENT_LOG=1 vvv docker build -t "${candidate}" -f "${dockerfile}" "${wd}"
    ret=$?
else
    debug "Skip build of ${tag} :: ${dockerfile} :: ${wd}"
fi

# Assure to have one candidate
if [[ ${ret} == 0 ]];then
    candidate_id=$(get_image "${candidate}")
    if [[ -z ${candidate_id} ]]; then
        log "Candidate not found: ${candidate}"
        ret=1
    fi
fi

cleanup_tag() {
    local old_tag_or_id="$1" tag="$2" suf="$3"
    if [[ -z ${old_tag_or_id} ]];then
        debug "Skip cleanup, no old tag id for $tag (${suf})"
        return 0
    fi
    if [[ -z ${tag} ]];then
        debug "Skip cleanup, no tag for $tag (${suf})"
        return 0
    fi
    local ctag_id=$(vv docker inspect -f '{{.Id}}' "${old_tag_or_id}" 2>/dev/null)
    local dtag_id=$(vv docker inspect -f '{{.Id}}' "${tag}" 2>/dev/null)
    if [[ -z "${ctag_id}" ]];then
        log "Old image id for ${old_tag_or_id} not found, skipping tag cleanup for $tag"
        return 0
    fi
    if [[ -z "${dtag_id}" ]];then
        log "Image ${tag} not found, skipping tag cleanup for $tag"
        return 0
    fi
    if [[ "${dtag_id}" != "${ctag_id}" ]];then
        # delete by id to be sure to delete an image which has only one tag
        # left, the 'squashed tag'
        SILENT=1 vvv docker rmi "${old_tag_or_id}" >/dev/null 2>&1
        if [[ ${?} != 0 ]];then
            # retry to verify if the failure is because of dependant images
            # and we should not bail out here
            SILENT=1 vvv docker rmi "${old_tag_or_id}" 2>&1\
                | egrep -q 'image has dependent|being used'
            if [[ ${?} != 0 ]];then
                vvv docker rmi "${old_tag_or_id}"
                die "Error when cleaning ${suf} tag: ${tag}/${old_tag_or_id}/${ctag_id}/${dtag_id}"
            else
                debug "skip tag $tag cleanup: has dependant images"
            fi
        else
            log "Cleaned ${suf} tag: ${tag}"
        fi
    else
        log "We do not have produced a new image for ${tag}"
    fi
}

# Maybe squash produced candidate
if [[ ${ret} == 0 ]]; then
    if [[ -z ${NO_SQUASH} ]];then
        log "Squashing to ${candidate_squashed}"
        taggued=${candidate_squashed}
        case "${SQUASHER}" in
            $SQUASHER_GO)
                SILENT_LOG=1 vvv docker save "${candidate_id}" \
                    | SILENT_LOG=1 vv "${SQUASHER}" \
                        -t "${candidate_squashed}" \
                        $( [[ -n "${ancestor_id}" ]] && echo  "-from '${ancestor_id}'" ) \
                    | SILENT_LOG=1 vvv docker load
                ret=$?
                ;;
            *)
                SILENT_LOG=1 vv "${SQUASHER}" \
                    -t "${candidate_squashed}" \
                    $( [[ -n "${ancestor_id}" ]] && echo  "-f ${ancestor_id}" ) \
                    ${candidate_id}
                ret=$?
                ;;
        esac
        if [[ ${ret} == 0 ]]; then
            log "Squashed ${tag} :: ${dockerfile} :: ${wd}"
            squashed_id=$(get_image "${candidate_squashed}")
        fi
    else
        debug "Skip squash of ${tag} :: ${dockerfile} :: ${wd}"
    fi
fi

# Everything has gone well, tag back candidate to img
if [[ ${ret} == 0 ]];then
    log "Tagging candidate ${taggued} to ${tag}"
    SILENT_LOG=1 vvv docker tag "${taggued}" "${tag}"
    ret=${?}
    if [[ ${ret} == 0 ]];then
        tag_id=$(get_image "${tag}")
    else
        log "${tag} tag failed"
    fi
fi

# Last cleanup bits (cleanup if found leftover squashed candidates
if [[ ${ret} == 0 ]]; then
    if [[ -z ${NO_CANDIDATE_CLEANUP} ]]; then
        cleanup_tag "${old_candidate_id}" "${candidate}" candidate
    else
        debug "Skip old candidate cleanup of ${tag} :: ${dockerfile} :: ${wd}"
    fi
    if [[ -z ${NO_SQUASH} ]] && [[ -z ${NO_SQUASH_CLEANUP} ]]; then
        cleanup_tag "${old_squashed_id}" "${candidate_squashed}" squashed
    else
        debug "Skip squashed image tag cleanup"
    fi
    if [[ -z ${NO_OLD_IMAGE_CLEANUP} ]]; then
        cleanup_tag "${old_tag_id}" "${tag}" image
    else
        debug "Skip old image cleanup of ${tag} :: ${dockerfile} :: ${wd}"
    fi
fi

if [[ -z ${tag_id} ]];then
    log "We do not have anymore an image for ${tag}"
    ret=8
fi

debug "${0} ret: ${ret}"
if [[ ${ret} == 0 ]];then
    log "${YELLOW}Image: ${NORMAL}${CYAN}${tag} ${NORMAL}${YELLOW}built"
else
    log "${YELLOW}Image: ${NORMAL}${CYAN}${tag} ${NORMAL}${YELLOW}build failed"
fi
exit ${ret}
# vim:set et sts=4 ts=4 tw=80:
