#!/usr/bin/env bash
export COPS_ROOT=/srv/corpusops/corpusops.bootstrap

# scripts vars
SCRIPT=$0
LOGGER_NAME=${LOGGER_NAME-$(basename $0)}
SCRIPT_NAME=$(basename "${SCRIPT}")
SCRIPT_DIR=$(cd "$(dirname $0)" && pwd)
# OW: from where script was called (must be defined from callee)
OW="${OW:-$(pwd)}"
# W is script_dir/..
W=${W:-$(cd "$SCRIPT_DIR/.." && pwd)}
# colors
RED="\\e[0;31m"
CYAN="\\e[0;36m"
YELLOW="\\e[0;33m"
NORMAL="\\e[0;0m"
NO_COLOR=${NO_COLORS-${NO_COLORS-${NOCOLOR-${NOCOLORS-}}}}
LOGGER_NAME=${LOGGER_NAME:-corpusops_build}
ERROR_MSG="There were errors"
do_trap_() { rc=$?;func=$1;sig=$2;${func};if [ "x${sig}" != "xEXIT" ];then kill -${sig} $$;fi;exit $rc; }
do_trap() { rc=${?};func=${1};shift;sigs=${@};for sig in ${sigs};do trap "do_trap_ ${func} ${sig}" "${sig}";done; }
parse_cli() { parse_cli_common "${@}"; }
parse_cli_common() {
    USAGE=
    for i in ${@-};do
        case ${i} in
            --no-color|--no-colors|--nocolor|--no-colors)
                NO_COLOR=1;;
            -h|--help)
                USAGE=1;;
            *) :;;
        esac
    done
    reset_colors
    if [[ -n ${USAGE} ]]; then
        usage
    fi
}
log_() {
    reset_colors;msg_color=${2:-${YELLOW}};
    logger_color=${1:-${RED}};
    logger_slug="${logger_color}[${LOGGER_NAME}]${NORMAL} ";
    shift;shift;
    if [[ -n ${NO_LOGGER_SLUG} ]];then logger_slug="";fi
    printf "${logger_slug}${msg_color}$(echo "${@}")${NORMAL}\n" >&2;
    printf "" >&2;  # flush
}
reset_colors() { if [[ -n ${NO_COLOR} ]];then BLUE="";YELLOW="";RED="";CYAN="";fi; }
log() { log_ "${RED}" "${CYAN}" "${@}"; }
get_chrono() { date "+%F_%H-%M-%S"; }
cronolog() { log_ "${RED}" "${CYAN}" "($(get_chrono)) ${@}"; }
debug() { if [[ -n "${DEBUG// }" ]];then log_ "${YELLOW}" "${YELLOW}" "${@}"; fi; }
warn() { log_ "${RED}" "${CYAN}" "${YELLOW}[WARN] ${@}${NORMAL}"; }
bs_log(){ log_ "${RED}" "${YELLOW}" "${@}"; }
bs_yellow_log(){ log_ "${YELLOW}" "${YELLOW}" "${@}"; }
may_die() {
    reset_colors
    thetest=${1:-1}
    rc=${2:-1}
    shift
    shift
    if [ "x${thetest}" != "x0" ]; then
        if [[ -z "${NO_HEADER-}" ]]; then
            NO_LOGGER_SLUG=y log_ "" "${CYAN}" "Problem detected:"
        fi
        NO_LOGGER_SLUG=y log_ "${RED}" "${RED}" "$@"
        exit $rc
    fi
}
die() { may_die 1 1 "${@}"; }
die_in_error_() {
    ret=${1}; shift; msg="${@:-"$ERROR_MSG"}";may_die "${ret}" "${ret}" "${msg}";
}
die_in_error() { die_in_error_ "${?}" "${@}"; }
has_command() {
    ret=1
    if which which >/dev/null 2>/dev/null;then
      if which "${@}" >/dev/null 2>/dev/null;then
        ret=0
      fi
    else
      if command -v "${@}" >/dev/null 2>/dev/null;then
        ret=0
      else
        if hash -r "${@}" >/dev/null 2>/dev/null;then
            ret=0
        fi
      fi
    fi
    return ${ret}
}
pipe_return() {
    local filter=$1;shift;local command=$@;
    (((($command; echo $? >&3) | $filter >&4) 3>&1) | (read xs; exit $xs)) 4>&1;
}
output_in_error() { ( do_trap output_in_error_post EXIT TERM QUIT INT;\
                      output_in_error_ "${@}" ; ); }
output_in_error_(){
    if [[ -n ${OUTPUT_IN_ERROR_DEBUG-} ]];then set -x;fi
    if [[ -n $TRAVIS ]] || [[ -n $GITLAB_CI ]];then
        DEFAULT_CI_BUILD=y
    fi
    CI_BUILD="${CI_BUILD-${DEFAULT_CI_BUILD-}}"
    if [[ -n $CI_BUILD ]];then
        DEFAULT_NO_OUTPUT=y
        DEFAULT_DO_OUTPUT_TIMER=y
    fi
    VERBOSE="${VERBOSE-}"
    TIMER_FREQUENCE="${TIMER_FREQUENCE:-120}"
    NO_OUTPUT="${NO_OUTPUT-${DEFAULT_NO_OUTPUT-1}}"
    DO_OUTPUT_TIMER="${DO_OUTPUT_TIMER-$DEFAULT_DO_OUTPUT_TIMER}"
    LOG=${LOG-}
    if [[ -n $NO_OUTPUT ]];then
        if [[ -z "${LOG}" ]];then
            LOG=$(mktemp)
            DEFAULT_CLEANUP_LOG=y
        else
            DEFAULT_CLEANUP_LOG=
        fi
    else
        DEFAULT_CLEANUP_LOG=
    fi
    CLEANUP_LOG=${CLEANUP_LOG:-${DEFAULT_CLEANUP_LOG}}
    if [[ -n $VERBOSE ]];then
        log "Running$([[ -n $LOG ]] && echo "($LOG)"; ): $@";
    fi
    TMPTIMER=
    if [[ -n ${DO_OUTPUT_TIMER} ]]; then
        TMPTIMER=$(mktemp)
        ( i=0;\
          while test -f $TMPTIMER;do\
           i=$((++i));\
           if [ `expr $i % $TIMER_FREQUENCE` -eq 0 ];then \
               log "BuildInProgress$([[ -n $LOG ]] && echo "($LOG)"; ): ${@}";\
             i=0;\
           fi;\
           sleep 1;\
          done;\
          if [[ -n $VERBOSE ]];then log "done: ${@}";fi; ) &
    fi
    if [[ -n $NO_OUTPUT ]];then
        "${@}" >>"$LOG" 2>&1;ret=$?
    else
        if [[ -n $LOG ]] && has_command tee;then
            pipe_return "tee -a $LOG" "${@}";ret=$?
        else
            "${@}";ret=$?
        fi
    fi
    if [[ -e "$TMPTIMER" ]]; then rm -f "${TMPTIMER}";fi
    if [[ -z ${OUTPUT_IN_ERROR_NO_WAIT-} ]];then wait;fi
    if [ -e "$LOG" ] &&  [[ "${ret}" != "0" ]] && [[ -n $NO_OUTPUT ]];then
        cat "$LOG" >&2
    fi
    if [[ -n ${OUTPUT_IN_ERROR_DEBUG-} ]];then set +x;fi
    return ${ret}
}
output_in_error_post() {
    if [[ -e "$TMPTIMER" ]]; then rm -f "${TMPTIMER}";fi
    if [[ -e "$LOG" ]] && [[ -n $CLEANUP_LOG ]];then rm -f "$LOG";fi
}
test_silent_log() { ( [[ -z ${NO_SILENT-} ]] && ( [[ -n ${SILENT_LOG-} ]] || [[ -n "${SILENT_DEBUG}" ]] ) ); }
test_silent() { ( [[ -z ${NO_SILENT-} ]] && ( [[ -n ${SILENT-} ]] || test_silent_log ) ); }
silent_run_() { (LOG=${SILENT_LOG:-${LOG}};NO_OUTPUT=;\
                 if test_silent;then NO_OUTPUT=y;fi;output_in_error "$@";) }
silent_run() { ( silent_run_ "${@}" ; ); }
run_silent() { SILENT=${SILENT-1} silent_run "${@}"; }
vvv() { debug "${@}";silent_run "${@}"; }
vv() { log "${@}";silent_run "${@}";}
silent_vv() { SILENT_LOG=${SILENT_LOG-} SILENT=${SILENT-1} vv "${@}"; }
get_command() {
    local p=
    local cmd="${@}"
    if which which >/dev/null 2>/dev/null;then
        p=$(which "${cmd}" 2>/dev/null)
    fi
    if [ "x${p}" = "x" ];then
        p=$(export IFS=:;
            echo "${PATH-}" | while read -ra pathea;do
                for pathe in "${pathea[@]}";do
                    pc="${pathe}/${cmd}";
                    if [ -x "${pc}" ]; then
                        p="${pc}"
                    fi
                done
                if [ "x${p}" != "x" ]; then echo "${p}";break;fi
            done )
    fi
    if [ "x${p}" != "x" ];then
        echo "${p}"
    fi
}
get_full_chrono() { date "+%F_%H-%M-%S-%N"; }
get_random_slug() { len=${1:-32};strings=${2:-'a-zA-Z0-9'};echo "$(cat /dev/urandom|tr -dc "$strings"|fold -w ${len}|head -n 1)"; }
get_container_id() { local n=${1};local cid=$(docker ps -q -a --filter 'name='$n); echo "${cid}"; }
may_sudo() {
    if [ "$(whoami)" != "root" ] && [ -z "${NO_SUDO-}" ];then
        echo "sudo $([[ -z $DIRECT_SUDO ]] && echo "-HE")"
    fi
}

usage () {
    NO_HEADER=y die '
Test script for ansible roles in ./roles or arbitrary rolepath
against a set of docker \$IMAGES.

 [NO_SUDO=] \
 [NO_CLEANUP=] \
 [NO_TESTS_OUTPUT=] \
 [NO_FORCE_USER_TAG=] \
 [IMAGES=xxx] \
 [ROLES_TO_TEST=]\
 [NOT_IN_DOCKER=]
 [SYNC_CORPUSOPS=y] \
 [ROLE_TESTSCRIPT_TEMPLATE=xxx]
 [NOCOLOR=y] \
 [DEBUG=y] \
    '"$0" [role1] [role2]'
'
}

parse_cli() {
    parse_cli_common "${@}"
}

parse_cli "$@"

failed_roles=""
success_roles=""
role_num=0

tmp_files=""
tmp_dockers=""
tmp_imgs=""
ROLE_TESTSCRIPT_TEMPLATE=${ROLE_TESTSCRIPT_TEMPLATE:-${W}/hacking/test_script.role}

post_tests_cleanup() {
    if [[ -n "${NO_CLEANUP}" ]]; then
        log "Skip Post tests cleanup"
    else
        vvv do_tmp_cleanup "${tmp_files}" "${tmp_dockers}" "${tmp_imgs}"
    fi
}

testscript_template() {
    role=$1
    t="${role}/testcript"
    if [ -e "$t" ];then
        r="$t"
    else
        r="${ROLE_TESTSCRIPT_TEMPLATE}"
    fi
    echo "$r"
}

do_tmp_cleanup() {
    local tmp_dockers=$2
    local tmp_files=$1
    local tmp_imgs=$3
    log "Post cleanup"
    for tmp_file in ${tmp_files};do
        if [ -e "${tmp_file}" ]; then
            vv rm -f "${tmp_file}"
        fi
    done
    for test_docker in ${tmp_dockers};do
        test_dockerid=$(vvv get_container_id ${test_docker})
        if [[ "${test_dockerid}" != "" ]]; then
            log "Removing produced test docker ${test_docker}"
            docker rm -f "${test_dockerid}"
        fi
    done
    for test_tag in ${tmp_imgs};do
        test_tagid=$(vvv get_image ${test_tag})
        if [[ "${test_tagid}" != "" ]]; then
            log "Removing produced test image: ${test_tag}"
            docker rmi "${test_tagid}"
        fi
    done
}

test_role() {
    local rret=0
    image="${1}"
    while read role;do
        if [[ -n $role ]];then
            if echo "${role}" | egrep -vq '^/'; then
                if test -d "${OW}/${role}"; then
                    role="${OW}/${role}"
                elif test -d "${OW}/roles/${role}"; then
                    role="${OW}/roles/${role}"
                elif test -d "${W}/roles/${role}"; then
                    role="${W}/roles/${role}"
                fi
            fi
            role=$(echo "${role}" | sed -e 's#/\+$##g')
            roles="$(printf "$roles\n$role\n" | xargs -n1)"
            if ! test -d ${role}; then
                log "non existing role: ${role}"
                return 1
            fi
        fi
    done <<< "${ROLEPATHS-}"
    testscript="$(testscript_template $role)"
    tmpstr=$(get_random_slug 8)
    docker_test_tag=copstest_${tmpstr}
    if [[ -z "$roles" ]];then warn "no roles to test";return $rret;fi
    if ! ( echo "${image}" | egrep -q "\/?system"; ); then
        tmp_dockers="${tmp_dockers} ${docker_test_tag}"
        docker=$(get_command docker)
        privileged="--privileged"
        vv $(may_sudo) "$docker" run -ti $privileged -d --name="$docker_test_tag" \
            -e PYTHONUNBUFFERED=${PYTHONUNBUFFERED-1} \
            -e ANSIBLE_FORCE_COLOR=${ANSIBLE_FORCE_COLOR-true} \
            -e IMAGES="$IMAGES" \
            -e COPS_TESTSCRIPT="$testscript" \
            -e ROLEPATHS="$roles" \
            -v "/sys/fs/cgroup:/sys/fs/cgroup:ro" \
            -v "/var/lib/docker:/var/lib/docker" \
            -v "/var/run/docker:/var/run/docker" \
            -v "/var/run/docker.sock:/var/run/docker.sock" \
            -v "$W:$COPS_ROOT.orig" \
            $(\
                while read r;do
                    echo "-v"
                    echo "$r:$r.orig:ro"
                done < <(printf "$roles\n$testscript"|xargs -n1); ) \
            "${image}" > /dev/null
        if [[ $? != 0 ]];then
            log "$image failed to spawn"
            return 1
        else
            sleep 1
        fi
        vvv docker exec "$docker_test_tag" bash -c "printf ''"
        if [[ $? != 0 ]];then
            log "${docker_test_tag}@${image} does not accept commands"
            return 1
        fi
        # inject code in docker image (read/write)
        vvv $(may_sudo) "$docker" exec -t "$docker_test_tag" bash -c '
            while read i;do
                if [ -d "$i.orig" ] && [ ! -e "$i" ];then
                    mkdir -p "$i"
                fi && \
                if [ -e "${i}.orig" ];then
                    d="$i.orig"
                    e="$i"
                    if [ -d "$d" ];then
                        d="${d}/"
                        e="${e}/"
                    fi
                    rsync -a --delete "${d}" "${e}"
                fi
            done < <( printf "$ROLEPATHS\n$COPS_TESTSCRIPT\n"|xargs -n1; )'
        if [[ $rret == 0 ]] && [[ -n "${SYNC_CORPUSOPS-}" ]];then
            vvv $(may_sudo) "$docker" exec -t "$docker_test_tag" bash -c '
                if [ -e "${COPS_ROOT}.orig/bin" ];then
                    rsync -av --delete "${COPS_ROOT}.orig/" "${COPS_ROOT}/" \
                        --exclude=venv/{bin,include,lib,local,man} \
                        --exclude=*pyc
                fi'
        fi
        rret=$?
        if [[ $rret == 0 ]];then
            vvv $(may_sudo) "$docker" exec "$docker_test_tag" bash -c '
                chmod +x $COPS_TESTSCRIPT && ${COPS_TESTSCRIPT}'
            rret=${?}
        fi
    else
        chmod +x "$testscript" &&\
        ( \
            export ROLEPATHS="$roles";\
            export COPS_ROOT="$W";\
            cd "${role}" && $(may_sudo) ${testscript}; )
        rret=${?}
    fi
    return ${rret}
}


get_roles_to_test() {
    local roles_to_test="${@}"
    echo "${roles_to_test}"|xargs -n1|awk '!seen[$0]++'
}

ret=0
if [[ -n $NOT_IN_DOCKER ]];then IMAGES=system;fi
do_trap post_tests_cleanup EXIT
roles_to_test=$(get_roles_to_test $@)
sroles_to_test=$(echo ${roles_to_test})
export ROLEPATHS=$roles_to_test;
while read image_line;do
    for image in ${image_line};do
        test_slug="$image::'$sroles_to_test'"
        log "Test (start:$(get_chrono)): $test_slug"
        ( export ROLEPATHS=$roles_to_test;
          do_trap post_tests_cleanup EXIT;
          test_role ${image};itret=$?\
          post_tests_cleanup;
          exit $itret; )
        tret=$?
        log "Test (end:$(get_chrono), rc:$tret): $test_slug"
        if [[ ${tret} != 0 ]];then
            ret=1
            failed_roles="${failed_roles} ${test_slug}"
        else
            success_roles="${success_roles} ${test_slug}"
        fi
    done
done <<< ${IMAGES}
if [[ -n ${success_roles} ]];then
    log "success roles suite:${YELLOW}${success_roles}"
fi
if [[ -n ${failed_roles} ]];then
    log "failed roles suite:${YELLOW}${failed_roles}"
fi
exit ${ret}
# vim:set et sts=4 ts=4 tw=80:
